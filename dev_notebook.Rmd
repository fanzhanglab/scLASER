---
title: "R Notebook"
output: html_notebook
---


```{r}

getwd()

setwd("Downloads")
```




```{r}
library(scLASER)
```


```{r}
obj = readRDS("scLASER_obj-2.rds")
```


```{r}
obj1 = scLASER(obj@metadata,obj@pcs)
```



```{r}
obj1 <- run_harmony(
  obj1,
  batch_col = "sample_id",
  theta = 2,
  epsilon.cluster = -Inf,
  epsilon.harmony = -Inf,
  max.iter.cluster = 30,
  max.iter.harmony = 10,
  plot_convergence = FALSE
)
```



```{r}




obj1@metadata$disease = obj1@metadata$disease %>% as.numeric()
obj1 <- association_nam_LV(
  obj = obj1,
  test_var = "disease",
  samplem_key = "sample_id",
  graph_use = "RNA_nn",
  batches = "batch",
  covs = c("age", "sex"),
  Nnull = 1000,
  local_test = TRUE,n_pcs = 20,
  seed = 1234, return_nam = T, key = "NAM_"
)


```




assosiation function long analysis



```{r}


forAnalysis <- data.frame(meta, nam_pcs)
forAnalysis$visit_factor <- paste0("V", forAnalysis$visit)
outcomes <- colnames(nam_pcs)

# 2 time point, not selecting
# function for association
getLMM <- function(pc){
  tmp <- forAnalysis
  tmp$nam_PC <- tmp[,which(colnames(tmp) == pc)]

  mod <- lme(fixed = nam_PC ~ disease*visit + age + sex, 
             random = ~ 1 | subject_id/sample_id, 
             data = tmp, method="ML")
  null <- lme(fixed = nam_PC ~ disease + visit + age + sex, 
             random = ~ 1 | subject_id/sample_id, 
             data = tmp, method="ML")
  
  full_tTab <- summary(mod)$tTable
  lrt <- anova(null, mod)
  lrt_pval <- lrt$`p-value`[2]
  want = data.frame(NAMscore = pc, coefficient = rownames(full_tTab), full_tTab, lrt_pval = lrt_pval)
}


#selecting






```


```{r}

devtools::install_github("fanzhanglab/scLASER",auth_token  = "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",force = T)

```



## fixing the data simulation 

```{r}

# old function
set.seed(2020)
test_old <- scLASER::generate_dummy_data(
  n_cells = 150,
  sd_celltypes = 0.1,
  n_major_cell_types = 7,
  n_minor_cell_types = 3,
  relative_abundance = 0.4,
  n_major_interact_celltypes = 2,
  n_minor_interact_celltypes = 2,
  n_individuals = 30,
  n_batchs = 4,
  interaction_feature = "visit",
  time_points = 3,
  test_var = "disease",
  prop_disease = 0.5,
  fc_interact = 0.6,
  interaction_type = "specific",
  seed = 2020,
  visit_effects_progressor = c(0.00, 0.60, 0.30),
  visit_effects_control    = c(0, 0, 0),
  direction_by_cluster     = c(+1, -1, +1, -1)
)
```


```{r}
#new function

#' Title
#'
#' @param n_cells
#' @param sd_celltypes
#' @param n_major_cell_types
#' @param n_minor_cell_types
#' @param relative_abundance
#' @param n_major_interact_celltypes
#' @param n_minor_interact_celltypes
#' @param n_individuals
#' @param n_batchs
#' @param interaction_feature
#' @param time_points
#' @param test_var
#' @param prop_disease
#' @param fc_interact
#' @param interaction_type
#' @param seed
#' @param visit_effects_progressor
#' @param visit_effects_control
#' @param direction_by_cluster
#'
#' @return
#' @export
#'
#' @examples
generate_dummy_data_new <- function(
  n_cells = 3000,                  # baseline cells per major cell type per sample
  sd_celltypes = 0.10,             # relative sd for counts
  n_major_cell_types = 7,
  n_minor_cell_types = 3,
  relative_abundance = 0.10,       # minor vs major baseline ratio
  n_major_interact_celltypes = 1,  # how many majors are "interacting"
  n_minor_interact_celltypes = 1,  # how many minors are "interacting"
  n_individuals = 30,
  n_batchs = 4,

  interaction_feature = "visit",   # kept for labeling
  time_points = 4,                 # >= 2; works for 3+
  test_var = "disease",
  prop_disease = 0.50,

  fc_interact = 0.10,              # effect magnitude used by defaults below
  interaction_type = c("specific","differential","opposite"),
  seed = 1234,

  visit_effects_progressor = NULL, # multiplicative change: +0.1 means +10% vs baseline
  visit_effects_control    = NULL, # default 0s
  direction_by_cluster     = NULL  # +1/-1 for interacting clusters, recycled as needed
) {
  set.seed(seed)
  interaction_type <- match.arg(interaction_type)

  # --- Basic setup ----
  n_cell_types <- n_major_cell_types + n_minor_cell_types
  stopifnot(time_points >= 2, n_cell_types >= 1)

  cell_types <- LETTERS[seq_len(n_cell_types)]
  major_idx  <- seq_len(n_major_cell_types)
  minor_idx  <- if (n_minor_cell_types > 0) (n_major_cell_types + seq_len(n_minor_cell_types)) else integer(0)

  # which cell types are "interacting" (first some majors, last some minors)
  interact_idx <- c(
    head(major_idx, n_major_interact_celltypes),
    tail(seq_len(n_cell_types), n_minor_interact_celltypes)
  )
  interact_idx <- intersect(interact_idx, seq_len(n_cell_types))  # guard rails
  interact_cell_types <- cell_types[interact_idx]

  # --- Subjects and visits ----
  subject_id <- paste0("SUB_", seq_len(n_individuals))
  disease_vec <- c(rep(1L, round(n_individuals * prop_disease)),
                   rep(0L, n_individuals - round(n_individuals * prop_disease)))
  disease_vec <- sample(disease_vec, n_individuals)

  sex_vec <- sample(c(0L, 1L), n_individuals, replace = TRUE)          # 0/1
  age_vec <- sample(18:60, n_individuals, replace = TRUE)
  bmi_vec <- sample(15:35, n_individuals, replace = TRUE)
  batch_vec <- rep(seq_len(n_batchs), length.out = n_individuals)

  subjects <- data.frame(
    subject_id = subject_id,
    sex   = sex_vec,
    disease = disease_vec,           # canonical exposure storage
    age   = age_vec,
    bmi   = bmi_vec,
    batch = factor(batch_vec),
    stringsAsFactors = FALSE
  )

  visits <- data.frame(
    subject_id = rep(subject_id, each = time_points),
    visit      = rep(0:(time_points - 1), times = n_individuals),
    stringsAsFactors = FALSE
  )
  visits$sample_id <- paste0(visits$subject_id, "_V", visits$visit)

  meta <- merge(visits, subjects, by = "subject_id", sort = FALSE)

  # Make sure a column named `test_var` exists (even if test_var != "disease")
  if (!identical(test_var, "disease")) {
    meta[[test_var]] <- meta[["disease"]]
  }

  # Label and INTERACTION TERM (persist to output)
  meta$interaction    <- paste0(interaction_feature, ":", test_var)
  meta$interact_term  <- as.integer(meta[[interaction_feature]]) * as.integer(meta[[test_var]])

  # --- Default visit effects (length = time_points) ----
  if (is.null(visit_effects_progressor)) {
    if (interaction_type == "specific") {
      ve <- rep(0, time_points)
      if (time_points >= 2) ve[2] <- fc_interact  # bump V1 only
      visit_effects_progressor <- ve
    } else if (interaction_type == "differential") {
      visit_effects_progressor <- rep(fc_interact, time_points)
    } else { # "opposite": alternate +/- starting at V0
      ve <- rep(0, time_points)
      ve[seq(1, time_points, by = 2)] <- +fc_interact  # V0, V2, ...
      if (time_points >= 2) ve[seq(2, time_points, by = 2)] <- -fc_interact # V1, V3, ...
      visit_effects_progressor <- ve
    }
  }
  if (is.null(visit_effects_control)) {
    visit_effects_control <- rep(0, time_points)
  }
  stopifnot(length(visit_effects_progressor) == time_points,
            length(visit_effects_control)    == time_points)

  # Direction per interacting cluster
  if (is.null(direction_by_cluster)) {
    # old default: all interacting cell types go in the same direction (+1)
    direction_by_cluster <- rep(1L, max(1, length(interact_cell_types)))
    names(direction_by_cluster) <- interact_cell_types
  } else {
    if (!is.null(names(direction_by_cluster))) {
      # NEW: user passed a *named* vector, e.g. c(A = 1, C = -1, J = 1)
      # We align to interact_cell_types and default missing ones to +1.
      tmp <- rep(1L, max(1, length(interact_cell_types)))
      names(tmp) <- interact_cell_types

      matched <- intersect(names(direction_by_cluster), interact_cell_types)
      tmp[matched] <- direction_by_cluster[matched]

      direction_by_cluster <- tmp
    } else {
      # old behavior for unnamed vector: recycle over interacting cell types
      direction_by_cluster <- rep(direction_by_cluster,
                                  length.out = length(interact_cell_types))
      names(direction_by_cluster) <- interact_cell_types
    }
  }

  # --- Baseline counts per (sample, cell_type) ----
  one_sample_counts <- function() {
    major_counts <- round(runif(n_major_cell_types,
                                min = n_cells * (1 - sd_celltypes),
                                max = n_cells * (1 + sd_celltypes)))
    minor_counts <- if (n_minor_cell_types > 0) {
      round(runif(n_minor_cell_types,
                  min = n_cells * relative_abundance * (1 - sd_celltypes),
                  max = n_cells * relative_abundance * (1 + sd_celltypes)))
    } else integer(0)
    c(major_counts, minor_counts)
  }

  counts_list <- replicate(nrow(meta), one_sample_counts(), simplify = FALSE)
  counts_df <- do.call(rbind, counts_list)
  colnames(counts_df) <- cell_types

  counts_long <- reshape(
    data.frame(sample_id = meta$sample_id, counts_df, check.names = FALSE),
    varying = cell_types, v.names = "count", timevar = "cell_type",
    times = cell_types, direction = "long"
  )
  rownames(counts_long) <- NULL

  # Merge disease/visit so we can apply effects
  counts_long <- merge(counts_long,
                       meta[, c("sample_id", "visit", "disease")],
                       by = "sample_id", sort = FALSE)

  # --- Apply effects only to interacting cell types ----
  is_interacting <- counts_long$cell_type %in% interact_cell_types
  eff_vec <- numeric(nrow(counts_long))
  if (any(is_interacting)) {
    # map direction per cell type
    dir_map <- setNames(direction_by_cluster, nm = names(direction_by_cluster))
    dir_ct  <- unname(dir_map[counts_long$cell_type[is_interacting]])
    # visit effects by group
    v_idx   <- counts_long$visit[is_interacting] + 1L
    is_prog <- counts_long$disease[is_interacting] == 1L
    ve      <- ifelse(is_prog, visit_effects_progressor[v_idx], visit_effects_control[v_idx])
    eff_vec[is_interacting] <- dir_ct * ve
  }

  counts_long$adj_count <- pmax(0L, round(counts_long$count * (1 + eff_vec)))

  # --- Expand to per-cell rows and attach metadata (INCLUDING interact_term) ----
  rep_each <- function(x, times) if (length(x) == 0) x else rep(x, times = times)
  expanded <- data.frame(
    sample_id = rep_each(counts_long$sample_id, counts_long$adj_count),
    cell_type = rep_each(counts_long$cell_type, counts_long$adj_count),
    stringsAsFactors = FALSE
  )

  # Merge metadata; keep interaction + interact_term
  keep_cols <- c("sample_id","subject_id","visit","sex","disease","age","bmi","batch",
                 "interaction","interact_term")
  dummy_data <- merge(expanded, meta[, keep_cols], by = "sample_id", sort = FALSE)

  # Shuffle rows for realism
  if (nrow(dummy_data) > 1) {
    dummy_data <- dummy_data[sample.int(nrow(dummy_data)), , drop = FALSE]
    rownames(dummy_data) <- NULL
  }

  dummy_data
}





```



```{r}
set.seed(2020)
test_new <- generate_dummy_data_new(
  n_cells = 150,
  sd_celltypes = 0.1,
  n_major_cell_types = 7,
  n_minor_cell_types = 3,
  relative_abundance = 0.4,
  n_major_interact_celltypes = 2,
  n_minor_interact_celltypes = 2,
  n_individuals = 30,
  n_batchs = 4,
  interaction_feature = "visit",
  time_points = 3,
  test_var = "disease",
  prop_disease = 0.5,
  interaction_type = "specific",
  seed = 2020,
  visit_effects_progressor = c(0.00, 0.60, 0.30),
  visit_effects_control    = c(0, 0, 0),

  #  directions for the interacting cell types A, B, I, J
  direction_by_cluster     = c(A = +1,  # enrich A
                               B = -1,  # deplete B
                               I = +1,  # enrich I
                               J = -1)  # deplete J
)
```



```{r}
test_new
test_old
```








### PLSDA function modification station

```{r}
#' PLS-DA step for scLASER objects using mixOmics
#'
#' Wrapper around [mixOmics::plsda()] that pulls the feature matrix from a
#' `scLASER` object, constructs class labels from metadata, optionally performs
#' multilevel decomposition, fits PLS-DA, and saves the latent variables
#' (component scores) into `object@plsda_LV`.
#'
#' Optionally, a subject-wise longitudinal cross-validation (CV) is performed,
#' where folds are created at the subject level (all visits for a subject are
#' kept in the same fold) and the Balanced Error Rate (BER) is computed for
#' 1..`cv_max_ncomp` components. CV results are attached as
#' `attr(object, "plsda_cv")`.
#'
#' @param object         A `scLASER` object.
#' @param response_var   Character. Column in `object@metadata` used as class
#'   label (default `"cell_type"`).
#' @param multilevel_var Optional character. Column in `object@metadata`
#'   identifying repeated-measures units (e.g. `"sample_id"`). If not `NULL`,
#'   multilevel PLS-DA is performed via [mixOmics::withinVariation()] prior
#'   to fitting.
#' @param ncomp          Integer. Number of latent components to compute for
#'   the main PLS-DA fit and for CV (upper bound).
#' @param cv_longitudinal Logical. If `TRUE`, perform subject-wise longitudinal
#'   CV as described above. Default is `FALSE`.
#' @param cv_subject_var Character. Column in `object@metadata` that defines
#'   the subject ID for CV folds (default `"subject_id"`).
#' @param cv_K           Integer. Number of folds for longitudinal CV
#'   (default `5`).
#' @param cv_max_ncomp   Integer. Maximum number of components to evaluate in
#'   longitudinal CV. Default is `ncomp`. Values greater than `ncomp` are
#'   truncated to `ncomp`.
#' @param cv_seed        Optional integer seed for reproducible fold creation.
#'   If `NULL`, the current RNG state is used.
#' @param ...            Additional arguments passed to [mixOmics::plsda()].
#'
#' @return A `scLASER` object with:
#'   \itemize{
#'     \item `@plsda_LV` populated with the PLS-DA latent variables
#'       (scores; `n_cells x ncomp`).
#'     \item If `cv_longitudinal = TRUE`, an attribute `plsda_cv` attached:
#'       `attr(object, "plsda_cv")`, a list with elements
#'       `ber` (numeric BER per component),
#'       `opt_ncomp` (optimal number of components),
#'       and `ncomp_seq` (sequence of components evaluated).
#'   }
#'
#' @export
#' @importFrom mixOmics plsda withinVariation
mixOmics_plsda <- function(object,
                           response_var    = "cell_type",
                           multilevel_var  = NULL,
                           ncomp           = 2,
                           cv_longitudinal = FALSE,
                           cv_subject_var  = "subject_id",
                           cv_K            = 5,
                           cv_max_ncomp    = ncomp,
                           cv_seed         = NULL,
                           ...) {

  stopifnot(inherits(object, "scLASER"))

  ## 1. Feature matrix from NAM_matrix ----
  X <- object@NAM_matrix
  if (is.null(X)) {
    stop(
      "object@NAM_matrix is NULL. ",
      "Please compute NAM_matrix before calling mixOmics_plsda()."
    )
  }
  X <- as.matrix(X)

  ## 2. Response from metadata ----
  meta <- object@metadata
  if (!response_var %in% colnames(meta)) {
    stop("response_var '", response_var, "' not found in object@metadata.")
  }
  Y <- factor(meta[[response_var]])

  if (nrow(X) != nrow(meta)) {
    stop(
      "Number of rows in NAM_matrix (", nrow(X),
      ") does not match number of rows in metadata (", nrow(meta), ")."
    )
  }

  ## 3. Optional multilevel design (withinVariation) ----
  if (!is.null(multilevel_var)) {
    if (!multilevel_var %in% colnames(meta)) {
      stop("multilevel_var '", multilevel_var,
           "' not found in object@metadata.")
    }
    design <- data.frame(sample = meta[[multilevel_var]])
    X <- withinVariation(X, design = design)
  }

  ## 4. Fit main PLS-DA model ----
  # Use mixOmics::plsda; ncomp is the max number of components we keep
 # fit <- plsda(X, Y, ncomp = ncomp, ...)

  # Latent variables (scores): n_cells x ncomp
  #LV <- fit$variates$X
  #object@plsda_LV <- as.matrix(LV)

  ## 5. Optional subject-wise longitudinal CV ----
  if (isTRUE(cv_longitudinal)) {
    if (!cv_subject_var %in% colnames(meta)) {
      stop("cv_subject_var '", cv_subject_var,
           "' not found in object@metadata.")
    }

    # Prepare subject-level table (unique (subject, class) combinations)
    subj_df <- meta[, c(cv_subject_var, response_var)]
    subj_df <- subj_df[!duplicated(subj_df), , drop = FALSE]

    # Randomize order of subjects for fold assignment
    if (!is.null(cv_seed)) {
      set.seed(cv_seed)
    }
    subj_df <- subj_df[sample(nrow(subj_df)), , drop = FALSE]

    # Build fold IDs, stratified by response class
    K <- cv_K
    fold_id <- integer(nrow(subj_df))
    for (cls in unique(subj_df[[response_var]])) {
      idx_cls <- which(subj_df[[response_var]] == cls)
      fold_id[idx_cls] <- rep(seq_len(K), length.out = length(idx_cls))
    }

    # List of subject IDs per fold
    subject_folds <- split(subj_df[[cv_subject_var]], fold_id)

    # Convert subject folds to row index folds (longitudinal, all visits)
    index_folds <- lapply(subject_folds, function(subj_grp) {
      which(meta[[cv_subject_var]] %in% subj_grp)
    })

    # Balanced Error Rate CV, similar to your manual code
    max_ncomp <- min(cv_max_ncomp, ncomp)
    n         <- nrow(X)
    classes   <- levels(Y)
    ber_cv    <- numeric(max_ncomp)

    for (nc in seq_len(max_ncomp)) {
      class_err_sum <- setNames(numeric(length(classes)), classes)
      class_n_sum   <- setNames(numeric(length(classes)), classes)

      for (fold in seq_along(index_folds)) {
        test_idx  <- index_folds[[fold]]
        train_idx <- setdiff(seq_len(n), test_idx)

        fit_fold <- plsda(
          X[train_idx, , drop = FALSE],
          Y[train_idx],
          ncomp = nc
        )

        pred <- mixOmics::predict(
          fit_fold,
          X[test_idx, , drop = FALSE],
          dist = "max.dist"
        )

        # Safely select available component
        ncomp_fit <- length(pred$class)
        ncomp_use <- min(nc, ncomp_fit)

        y_pred <- pred$class[[ncomp_use]]
        y_true <- Y[test_idx]

        for (cls in classes) {
          idx_cls_fold <- which(y_true == cls)
          if (length(idx_cls_fold) == 0) next

          err <- mean(y_pred[idx_cls_fold] != y_true[idx_cls_fold])
          class_err_sum[cls] <- class_err_sum[cls] + err * length(idx_cls_fold)
          class_n_sum[cls]   <- class_n_sum[cls]   + length(idx_cls_fold)
        }
      }

      class_err   <- class_err_sum / class_n_sum
      ber_cv[nc]  <- mean(class_err, na.rm = TRUE)
    }

    opt_ncomp <- which.min(ber_cv)

 fit <- plsda(X, Y, ncomp = opt_ncomp, ...)

  # Latent variables (scores): n_cells x ncomp
  LV <- fit$variates$X
  object@plsda_LV <- as.matrix(LV)
  }

  object
}

```

