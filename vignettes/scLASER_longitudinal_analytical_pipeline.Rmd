---
title: "<span style='font-size: 30px;'>Tutorial: applying scLASER to identify time-dependent cell dynamics on simulated three-timepoints single-cell data</span>"
author: |
  [Lab Website - https://fanzhanglab.org](https://fanzhanglab.org)  
  [Lab GitHub - https://github.com/fanzhanglab](https://github.com/fanzhanglab)
date: "`r format(Sys.Date())`"
output:
  rmarkdown::html_document:
    toc_float: true
    toc_depth: 3
    code_folding: show
    theme:
      version: 5
      bootswatch: flatly
      primary: "#984EA3"
      base_font: {google: "Inter"}
      heading_font: {google: "Inter"}
      code_font: {google: "Fira Code"}
vignette: >
  %\VignetteIndexEntry{scLASER Pipeline}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = FALSE,
  message = FALSE,
  fig.width = 7,
  fig.height = 4.5
)
```

```{r}
library(scLASER)
library(tidyverse)

```


```{r helper-plot-top-nam, echo=TRUE}


# Helper: pick the NAM PC with the smallest LRT p-value and plot it on UMAP
plot_top_nam_pc_umap <- function(object,
                                 p_col_candidates   = c("lrt_pval", "lrt_p", "p.value", "pval"),
                                 nam_col_candidates = c("NAMscore", "nam_pc", "pc", "NAM_PC", "score"),
                                 umap_col_candidates = list(
                                   x = c("UMAP1", "umap_1", "UMAP_1", "Dim1"),
                                   y = c("UMAP2", "umap_2", "UMAP_2", "Dim2")
                                 ),
                                 zscore = TRUE,
                                 facet_by = "disease",
                                 label_cell_types = TRUE,
                                 cell_type_col = "cell_type",
                                 label_size = 3) {

  stopifnot(inherits(object, "scLASER"))

  if (is.null(object@pipeline_output) || nrow(object@pipeline_output) == 0) {
    stop("object@pipeline_output is empty. Run longAnalyses_plusModelSelection() first.")
  }
  if (is.null(object@umap) || nrow(object@umap) == 0) {
    stop("object@umap is empty. Run compute_umap() first.")
  }
  if (is.null(object@nam_pcs) || nrow(object@nam_pcs) == 0) {
    stop("object@nam_pcs is empty. Run association_nam_scLASER() first.")
  }

  # Require row alignment across slots
  n_md  <- nrow(object@metadata)
  n_um  <- nrow(object@umap)
  n_nam <- nrow(object@nam_pcs)
  if (!(n_md == n_um && n_md == n_nam)) {
    stop(
      "Row mismatch across slots:\n",
      "  nrow(metadata) = ", n_md, "\n",
      "  nrow(umap)     = ", n_um, "\n",
      "  nrow(nam_pcs)  = ", n_nam, "\n",
      "These must match if you want to cbind() them."
    )
  }

  po <- object@pipeline_output

  # Find p-value column
  p_col <- p_col_candidates[p_col_candidates %in% colnames(po)][1]
  if (is.na(p_col)) {
    stop("Could not find an LRT p-value column in pipeline_output. Tried: ",
         paste(p_col_candidates, collapse = ", "))
  }

  # Find NAM PC identifier column
  nam_col <- nam_col_candidates[nam_col_candidates %in% colnames(po)][1]
  if (is.na(nam_col)) {
    stop("Could not find a NAM PC identifier column in pipeline_output. Tried: ",
         paste(nam_col_candidates, collapse = ", "))
  }

  po[[p_col]] <- as.numeric(po[[p_col]])
  po <- po[is.finite(po[[p_col]]), , drop = FALSE]
  if (nrow(po) == 0) stop("No finite p-values in pipeline_output.")

  top_row <- po[which.min(po[[p_col]]), , drop = FALSE]
  top_pc  <- as.character(top_row[[nam_col]])

  if (!top_pc %in% colnames(object@nam_pcs)) {
    stop("Top NAM PC '", top_pc, "' not found in colnames(object@nam_pcs).")
  }

  # UMAP coordinate columns
  um <- object@umap
  um1 <- umap_col_candidates$x[umap_col_candidates$x %in% colnames(um)][1]
  um2 <- umap_col_candidates$y[umap_col_candidates$y %in% colnames(um)][1]
  if (is.na(um1) || is.na(um2)) {
    stop("Could not find UMAP coordinate columns in object@umap.")
  }

  # Build plotting DF by row alignment
  plot_df <- cbind(object@metadata, object@umap)
  plot_df$nam_score <- as.numeric(object@nam_pcs[, top_pc])

  if (zscore) {
    plot_df$nam_score <- as.numeric(scale(plot_df$nam_score))
  }

  p <- ggplot2::ggplot(
    plot_df,
    ggplot2::aes(x = .data[[um1]], y = .data[[um2]], color = nam_score)
  ) +
    ggplot2::geom_point(size = 0.6, alpha = 0.85) +
    ggplot2::scale_color_gradient2(
      low = "#2C7BB6",   # blue
      mid = "white",
      high = "#D7191C",  # red
      midpoint = 0
    ) +
    ggplot2::labs(
      title = "Association Score (significant latent embedding, PC1)",
      subtitle = paste0("min LRT p = ", signif(top_row[[p_col]], 3)),
      x = "UMAP1",
      y = "UMAP2",
      color = if (zscore) paste0(top_pc, " (z)") else top_pc
    ) +
    ggplot2::theme_classic()

  # Facet (optional)
  if (!is.null(facet_by) && facet_by %in% colnames(plot_df)) {
    p <- p + ggplot2::facet_wrap(stats::as.formula(paste("~", facet_by)), nrow = 1)
  }

  # Add one label per cell type at median UMAP position
  if (isTRUE(label_cell_types)) {
    if (!cell_type_col %in% colnames(plot_df)) {
      stop("cell_type_col '", cell_type_col, "' not found in metadata/plot_df.")
    }

    label_df <- plot_df %>%
      dplyr::group_by(.data[[cell_type_col]]) %>%
      dplyr::summarise(
        .x = stats::median(.data[[um1]], na.rm = TRUE),
        .y = stats::median(.data[[um2]], na.rm = TRUE),
        .groups = "drop"
      ) %>%
      dplyr::rename(label = !!cell_type_col)

    p <- p +
      ggplot2::geom_text(
        data = label_df,
        ggplot2::aes(x = .x, y = .y, label = label),
        inherit.aes = FALSE,
        size = label_size
      )
  }

  p
}

```

------------------------------------------------------------------------



### <span style="font-size:25px;">A. Create an object for the single-cell data. The simulated cell abundances are visualized accordingly based on clinical outcome status</span>



```{r}
obj <- scLASER(metadata = readRDS("/Users/juanvargas/Documents/GitHub/scLASER/vignettes/metadata.rds"), pcs = readRDS("/Users/juanvargas/Documents/GitHub/scLASER/vignettes/pcs.rds"))

obj
plot_celltype_proportions(
  obj,
  disease_var = "disease",
  disease_labels = c("0" = "Non-responder", "1" = "Responder"),
  disease_colors = c("Non-responder" = "#4DAF4A", "Responder" = "#984EA3"),
  highlight_cell_types = NULL
)
```

### <span style="font-size:25px;"> What lives in a scLASER object (slots)</span>

A `scLASER` object is an S4 container that stores each intermediate output of the pipeline in a dedicated **slot**, so later steps can reuse results without recomputing them. In this tutorial we populate the slots in the following order:

-   `@metadata` — per-cell metadata (sample/subject IDs, visit, disease, covariates, etc.). Created by `generate_dummy_data()` and passed into `scLASER()`.
-   `@pcs` — synthetic principal components used as the working low-dimensional space. Created by `generate_pseudo_pcs_time()` and stored when you call `scLASER(metadata=..., pcs=...)`.
-   `@umap` — 2D UMAP embedding for visualization. Created by `compute_umap()`.
-   `@harmony` — batch-corrected PC embedding. Created by `run_harmony()`.
-   `@nam_pcs` — neighborhood abundance “PCs” (association score vectors). Created by `association_nam_scLASER()`.
-   `@NAM_matrix` — neighborhood abundance matrix used to derive `@nam_pcs` (also created by `association_nam_scLASER()`).
-   `@pipeline_output` — tidy results table from longitudinal model selection (including LRT p-values). Created by `longAnalyses_plusModelSelection()`.

### <span style="font-size:25px;">B. Visualizing data in UMAP, with data harmonized across samples</span>

```{r}
obj <- compute_umap(obj, n_neighbors = 30, metric = "cosine", min_dist = 0.01)

obj <- run_harmony(
  obj,
  batch_col = "sample_id",
  theta = 2,
  epsilon.cluster = -Inf,
  epsilon.harmony = -Inf,
  max.iter.cluster = 30,
  max.iter.harmony = 10,
  plot_convergence = FALSE
)

saveRDS(obj, "obj_scLASER.rds")
```

### <span style="font-size:25px;">C. Running main functions for longitudinal association modeling</span>

The following 2 functions `association_nam_scLASER` and `longAnalyses_plusModelSelection` are the main protagonist of our pipeline. In the previous steps, the goal was to harmonize the pcs to remove any batch effect. In these steps we create the Neighborhood Abundance Matrix from those harmonized pcs. Further we determine which of those NAM PCs or Association score vectors are associated with the interaction of response status and visit.

```{r}

obj = readRDS("obj_scLASER.rds")

obj@metadata$disease = as.numeric(obj@metadata$disease)
obj <- association_nam_scLASER(
  obj = obj,
  test_var = "disease",
  samplem_key = "sample_id",
  graph_use = "RNA_nn",
  batches = "batch",
  covs = c("age", "sex"),
  Nnull = 1000,
  local_test = TRUE,n_pcs = 20,
  seed = 1234, return_nam = T, key = "NAM_"
)

# Align names for longitudinal analysis + plotting
rownames(obj@nam_pcs) <- obj@metadata$sample_id

obj <- scLASER_modeling(obj,
  disease_var = "disease",
  time_var    = "visit",
  covariates  = c("age", "sex"),
  subject_var = "subject_id",
  sample_var  = "sample_id"
)


obj@pipeline_output

plot_top_nam_pc_umap(obj, facet_by = NULL,zscore = F )


saveRDS(obj, "obj_scLASER.rds")
```

